AI Usage Journal
Wang Xiang
wxiang1@terpmail.umd.edu
Section 0301

This week, I used AI to:
- Help me understand the instructions for the INST326 Week1 Exercises.
- Get an explanation of some basic Python topics (lists, dictionaries).
- Debug a small error in my Jupyter Notebook.
- Clarify how to create and submit this AI Journal on GitHub.



Week 2

This week I used AI as a tutor, debugger, and code reviewer while finishing the Week-2
“Library Management” Python exercises and a few SQL review questions. I did not ask AI to
do the whole assignment for me. Instead, I used AI to explain concepts, propose small
snippets, and then I rewrote/ran the code in my own notebook and kept links to the chats.

What I used AI for (Python):
- Reviewed core topics we needed this week: if/elif/else, while/for loops, list methods
  (append/insert/remove/pop/sort/reverse), slicing, membership checks, and boolean logic.
- Built and tested patterns I will reuse: toggling a boolean, counting items with a loop,
  “first match or −1”, “any available” vs “all available”, and a safe remove with an
  existence check.
- Fixed an IndexError in my availability report caused by different lengths of `titles`
  and `available`. AI suggested either aligning lists or using `zip(titles, available)`; I
  implemented the `zip` approach and verified the output.
- Wrote a simple menu loop (while + if/elif/else) to print all titles, print only available
  titles, then quit. I simulated inputs as a small list to avoid blocking the notebook.
- Practiced list organization tasks: moving an item with `pop`→`append`, manual title
  casing (first char upper, rest lower), alternating merge of two shelves, and a longest-
 title search via a loop (no `max` key).

What I used AI for (SQL):
- Reasoned about JOIN types from small screenshots: when a LEFT JOIN vs RIGHT JOIN is
  required, and how to combine tables like vendors → invoices → invoice_line_items
  (including USING). I verified the logic before answering the quiz.

Project work:
- Drafted parts of our App Project Contract (goals, expectations, policies, consequences,
  meeting times, rotating leaders). AI helped me list the sections and polish wording; our
  team edited the final text to reflect our decisions.

Reflection:
- Helpful: step-by-step error explanations and the “zip to avoid mismatched lengths”
  pattern. Also learned to be careful with repeated notebook cells that can append
  duplicates.
- Limits: AI sometimes assumes different data. I now always run cells, check lengths,
  and test edge cases.
- Attribution/Policy: When I used short idioms from AI (e.g., `zip` pattern) I kept the
  chat link. I typed and tested everything myself.




Week 3

This week I used AI mainly as a coding partner and explainer while working through the extended “Library Management” exercises and continuing SQL practice. I kept AI use focused on learning patterns, testing code, and checking my reasoning, not on outsourcing the full solutions.

What I used AI for (Python):

Asked for clean implementations of the later library functions (toggle, swap, insert, catalog summary). I pasted AI’s version into my notebook, then rewrote or simplified it line by line to make sure I understood loops, conditionals, and list operations.

Practiced edge-case reasoning: AI explained what happens if indices are out of range, or if I try to remove from an empty list. I tested those cases myself afterward.

Got help normalizing titles and authors: how to strip spaces, title-case, and handle multiple possible separators (— vs -). This clarified string handling and split vs rsplit.

Verified my code style: AI suggested shorter comprehensions and f-strings, which I compared against my original longer loops.

What I used AI for (SQL):

Reviewed JOIN logic with small practice prompts (when to use ON vs USING, handling duplicate column names).

Practiced writing queries that filter by substring (LIKE) and by range (BETWEEN). I asked AI to critique my WHERE clauses and then corrected them in my SQL tool.

Project work:

For our group project planning, I drafted a section of our document (roles + responsibilities). AI helped me brainstorm reasonable policies for task rotation and consequence handling, then I rephrased them into our own style.

I also asked AI how to format a catalog summary with totals and availability counts so I could adapt the idea to a team resource tracker.

Overall, AI acted like a tutor and reviewer. I always ran and modified the code myself, and I linked back to the chats for reference.






Week 4

This week, I used AI to:

Review the concepts of classes and objects in Python and understand the difference between attributes and methods.

Get examples of how to design a simple class for real-life objects (like a car or phone).

Ask for help writing and explaining __init__ and __str__ methods in my code.

Clarify how inheritance works and when to use it in a project.

Reflect on how AI can help generate or improve class design ideas for my future team project.






Week 5


This week, I used AI as both a debugging assistant and a concept explainer while working on the “Data Query and File Processing” lab. I encountered several Python and SQL tasks that required clarification of syntax and logical structure, so I asked AI to break down how each command worked and why certain approaches were more efficient.

What I used AI for:

Clarified how to read and write files in Python using open(), .readlines(), and context managers (with statements).

Asked AI to explain SQL query optimization, including when to use JOIN vs. WHERE filtering.

Debugged an issue in my code that was caused by incorrect indentation inside a loop when processing multiple files.

Learned how to use parameterized SQL queries in Python (cursor.execute() with placeholders) to prevent SQL injection and improve readability.

Requested small code examples that demonstrated how to use try/except blocks to handle missing files gracefully.

Reflection:
This week, AI helped me strengthen my understanding of file handling, data iteration, and safe SQL execution. I became more comfortable interpreting error messages and adjusting my logic instead of just copying code. I also learned to ask more specific, context-aware questions — for example, asking “why does this query return duplicates” instead of just “how to fix it.” This approach helped me use AI as a collaborative tool, not just a problem solver.




Week 6

This week, I used AI mainly as a conceptual assistant and a debugging partner while working on advanced Python topics related to object-oriented programming. I encountered areas that required deeper understanding, especially around class structure design, method types, and chaining multiple components together in a program. AI helped clarify differences between method scopes and supported me in validating logic flow.

What I used AI for:

Reviewed the differences between instance methods, class methods, and static methods, including when each is appropriate in real-world use cases.

Asked for explanations on how class attributes are shared across instances and how they differ from instance attributes.

Clarified how to manage internal counters (e.g., ID generators) and why class methods are suitable for such use.

Requested debugging guidance when I encountered incorrect behavior due to misusing self instead of cls in class methods.

Asked for help in improving code readability, such as how to properly separate responsibilities between helper classes and utility methods.

Explored examples of how static methods can encapsulate reusable logic without depending on object state.

Sought simplified analogies to better understand encapsulation and how to keep classes cohesive but not tightly coupled.

Reflection:

This week, AI helped me deepen my understanding of structured object-oriented design. Instead of treating classes as containers for random functions, I became more aware of how class responsibilities should be clearly defined. I also gained confidence in selecting the right type of method depending on the context. More importantly, I learned to validate my own reasoning by checking whether a method truly required access to instance data, class-level data, or could function independently. This helped shift my learning process from writing code that “works” to designing code that is logical, maintainable, and well-structured.





Week 7 Reflection

This week, I used AI primarily as a conceptual assistant and debugging partner while exploring advanced topics in Python related to object-oriented programming (OOP). I focused on understanding class structures, method scopes, and how to effectively connect multiple components within a program.

AI provided detailed guidance in distinguishing between instance methods, class methods, and static methods, helping me recognize when each should be applied in real-world scenarios. I also clarified the distinction between class attributes and instance attributes, learning how shared data and per-instance data should be managed differently.

Through debugging discussions, I realized why using cls instead of self is crucial in class methods, especially when maintaining internal counters or ID generators. AI also helped improve my code readability and modularity, offering suggestions for separating concerns between helper classes and utility functions.

Additionally, by exploring analogies for encapsulation and cohesion, I developed a better sense of how to design classes that are self-contained yet interact logically with other parts of the program.

Overall, this week’s learning deepened my understanding of OOP design principles. I moved from simply writing functional code to structuring programs with clarity, maintainability, and purpose, ensuring each class and method serves a well-defined role within the system.







Week 8 
This week, I continued expanding my understanding of object-oriented programming, focusing on the principles of inheritance and polymorphism. I explored how subclasses can extend or modify the behavior of parent classes and how method overriding enables customized behavior while maintaining structural consistency.

AI helped me clarify when to use super() to access base-class functionality and how polymorphism allows different objects to respond to the same method call in distinct yet logical ways. These concepts helped me see how inheritance supports both code reusability and adaptability in software systems.

Through conceptual guidance and debugging examples, I gained a clearer understanding of how to design hierarchies that promote modularity, reduce redundancy, and improve clarity. I also reflected on how polymorphism can replace rigid conditional logic, allowing programs to grow more naturally as new subclasses are introduced.

Overall, this week strengthened my grasp of how inheritance and polymorphism contribute to scalable and elegant program design. I learned to think about class relationships not only in terms of data organization but also in how behaviors evolve across related components.


Week 9

This week, I deepened my understanding of abstract classes and interface-like patterns in Python, focusing especially on how abstraction shapes clearer and more enforceable design contracts. I explored how abstract methods and properties define the essential operations that all subclasses must implement, ensuring consistency across different item types while still allowing customized behavior.

AI helped me better understand how abstract base classes differ from concrete inheritance and why relying on abstraction encourages more stable program structures. I learned how abstract properties can act as required attributes, guiding subclasses to provide their own logic while keeping the overall system predictable. The explanations also clarified how class methods can be declared abstract and how template methods allow a base class to define a shared workflow that subclasses personalize through overridden hooks.

Through conceptual breakdowns and debugging examples, I gained a more intuitive sense of how abstraction promotes decoupling and clean architecture. I also reflected on how enforcing an abstract contract eliminates the need for scattered type checks, since all subclasses commit to the same interface by design. This makes the system easier to extend as new item types are introduced without rewriting existing logic.

Overall, this week strengthened my appreciation for abstraction as a tool for scalable and maintainable software design. I learned to view classes not only as containers of data and behavior but also as agreements about what functionality should exist. This shift in perspective helped me understand how abstraction and interfaces support flexibility, consistency, and long-term adaptability in larger codebases.




Week 10

This week, I continued advancing my understanding of object-oriented programming by exploring composition, delegation, and how objects collaborate within larger program structures. I examined how composition differs from inheritance and how choosing between them affects flexibility, coupling, and long-term maintainability. I also reflected on how delegation allows objects to share responsibilities without forming rigid hierarchical relationships.

AI helped me deepen my awareness of when composition should be preferred over subclassing—especially in cases where behavior should be changed without altering the type hierarchy. Through explanations and debugging guidance, I learned how composed objects can encapsulate specialized functionality while keeping parent classes simpler and more focused. I also gained clarity on how delegation patterns reduce duplication and promote clearer separation of concerns.

Through conceptual examples and iterative refinements, I developed a stronger sense of how object collaboration forms the foundation of scalable program architecture. I reflected on how designing small, single-purpose objects leads to cleaner interactions and how composition allows systems to evolve without breaking existing structures. The guidance also showed how delegation can replace conditional decision trees, making behavior more modular and extendable.

Overall, this week strengthened my appreciation for composition as a powerful design tool, especially when aiming for flexible and maintainable systems. I learned to think of objects not only as independent entities but also as participants in cooperative workflows. This shift in perspective helped me understand how object collaboration supports extensibility, reduces coupling, and encourages long-term adaptability in complex codebases.







Week 12

This week, I expanded my understanding of object-oriented programming by focusing on error handling, defensive programming, and how robust systems maintain stability when unexpected situations occur. I explored how exceptions flow through a program, how to design predictable failure paths, and how good error-handling patterns improve reliability without complicating the overall architecture. I also reflected on how defensive programming practices protect core logic and prevent invalid states from propagating.

AI helped me clarify when exceptions should be raised versus when they should be handled silently, and how to structure try/except blocks to keep code readable while still capturing potential failure points. Through conceptual guidance, I gained a clearer sense of how validation, boundary checks, and fail-fast principles work together to strengthen the correctness of a system. The explanations also helped me understand how custom exceptions can communicate intent more clearly and support more maintainable debugging practices.

Through examples and iterative refinements, I developed a stronger appreciation for designing programs that expect the unexpected. I learned how strategic guard clauses can simplify logic, how layering validation helps prevent ambiguous states, and how anticipating misuse leads to more intuitive interfaces. I also reflected on how proper exception propagation creates a clean separation between business logic and error-resolution logic, allowing each part of the system to retain a focused responsibility.

Overall, this week deepened my understanding of reliability as an essential part of software design. I learned to view error handling not as an afterthought but as an integrated design concern that shapes how components interact and fail safely. This shift in perspective helped me recognize how defensive programming, validation patterns, and thoughtful exception design contribute to the creation of resilient, predictable, and maintainable codebases.
