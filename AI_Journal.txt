AI Usage Journal
Wang Xiang
wxiang1@terpmail.umd.edu
Section 0301

This week, I used AI to:
- Help me understand the instructions for the INST326 Week1 Exercises.
- Get an explanation of some basic Python topics (lists, dictionaries).
- Debug a small error in my Jupyter Notebook.
- Clarify how to create and submit this AI Journal on GitHub.



Week 2

This week I used AI as a tutor, debugger, and code reviewer while finishing the Week-2
“Library Management” Python exercises and a few SQL review questions. I did not ask AI to
do the whole assignment for me. Instead, I used AI to explain concepts, propose small
snippets, and then I rewrote/ran the code in my own notebook and kept links to the chats.

What I used AI for (Python):
- Reviewed core topics we needed this week: if/elif/else, while/for loops, list methods
  (append/insert/remove/pop/sort/reverse), slicing, membership checks, and boolean logic.
- Built and tested patterns I will reuse: toggling a boolean, counting items with a loop,
  “first match or −1”, “any available” vs “all available”, and a safe remove with an
  existence check.
- Fixed an IndexError in my availability report caused by different lengths of `titles`
  and `available`. AI suggested either aligning lists or using `zip(titles, available)`; I
  implemented the `zip` approach and verified the output.
- Wrote a simple menu loop (while + if/elif/else) to print all titles, print only available
  titles, then quit. I simulated inputs as a small list to avoid blocking the notebook.
- Practiced list organization tasks: moving an item with `pop`→`append`, manual title
  casing (first char upper, rest lower), alternating merge of two shelves, and a longest-
 title search via a loop (no `max` key).

What I used AI for (SQL):
- Reasoned about JOIN types from small screenshots: when a LEFT JOIN vs RIGHT JOIN is
  required, and how to combine tables like vendors → invoices → invoice_line_items
  (including USING). I verified the logic before answering the quiz.

Project work:
- Drafted parts of our App Project Contract (goals, expectations, policies, consequences,
  meeting times, rotating leaders). AI helped me list the sections and polish wording; our
  team edited the final text to reflect our decisions.

Reflection:
- Helpful: step-by-step error explanations and the “zip to avoid mismatched lengths”
  pattern. Also learned to be careful with repeated notebook cells that can append
  duplicates.
- Limits: AI sometimes assumes different data. I now always run cells, check lengths,
  and test edge cases.
- Attribution/Policy: When I used short idioms from AI (e.g., `zip` pattern) I kept the
  chat link. I typed and tested everything myself.




Week 3

This week I used AI mainly as a coding partner and explainer while working through the extended “Library Management” exercises and continuing SQL practice. I kept AI use focused on learning patterns, testing code, and checking my reasoning, not on outsourcing the full solutions.

What I used AI for (Python):

Asked for clean implementations of the later library functions (toggle, swap, insert, catalog summary). I pasted AI’s version into my notebook, then rewrote or simplified it line by line to make sure I understood loops, conditionals, and list operations.

Practiced edge-case reasoning: AI explained what happens if indices are out of range, or if I try to remove from an empty list. I tested those cases myself afterward.

Got help normalizing titles and authors: how to strip spaces, title-case, and handle multiple possible separators (— vs -). This clarified string handling and split vs rsplit.

Verified my code style: AI suggested shorter comprehensions and f-strings, which I compared against my original longer loops.

What I used AI for (SQL):

Reviewed JOIN logic with small practice prompts (when to use ON vs USING, handling duplicate column names).

Practiced writing queries that filter by substring (LIKE) and by range (BETWEEN). I asked AI to critique my WHERE clauses and then corrected them in my SQL tool.

Project work:

For our group project planning, I drafted a section of our document (roles + responsibilities). AI helped me brainstorm reasonable policies for task rotation and consequence handling, then I rephrased them into our own style.

I also asked AI how to format a catalog summary with totals and availability counts so I could adapt the idea to a team resource tracker.

Overall, AI acted like a tutor and reviewer. I always ran and modified the code myself, and I linked back to the chats for reference.






Week 4

This week, I used AI to:

Review the concepts of classes and objects in Python and understand the difference between attributes and methods.

Get examples of how to design a simple class for real-life objects (like a car or phone).

Ask for help writing and explaining __init__ and __str__ methods in my code.

Clarify how inheritance works and when to use it in a project.

Reflect on how AI can help generate or improve class design ideas for my future team project.






Week 5


This week, I used AI as both a debugging assistant and a concept explainer while working on the “Data Query and File Processing” lab. I encountered several Python and SQL tasks that required clarification of syntax and logical structure, so I asked AI to break down how each command worked and why certain approaches were more efficient.

What I used AI for:

Clarified how to read and write files in Python using open(), .readlines(), and context managers (with statements).

Asked AI to explain SQL query optimization, including when to use JOIN vs. WHERE filtering.

Debugged an issue in my code that was caused by incorrect indentation inside a loop when processing multiple files.

Learned how to use parameterized SQL queries in Python (cursor.execute() with placeholders) to prevent SQL injection and improve readability.

Requested small code examples that demonstrated how to use try/except blocks to handle missing files gracefully.

Reflection:
This week, AI helped me strengthen my understanding of file handling, data iteration, and safe SQL execution. I became more comfortable interpreting error messages and adjusting my logic instead of just copying code. I also learned to ask more specific, context-aware questions — for example, asking “why does this query return duplicates” instead of just “how to fix it.” This approach helped me use AI as a collaborative tool, not just a problem solver.




Week 6

This week, I used AI mainly as a conceptual assistant and a debugging partner while working on advanced Python topics related to object-oriented programming. I encountered areas that required deeper understanding, especially around class structure design, method types, and chaining multiple components together in a program. AI helped clarify differences between method scopes and supported me in validating logic flow.

What I used AI for:

Reviewed the differences between instance methods, class methods, and static methods, including when each is appropriate in real-world use cases.

Asked for explanations on how class attributes are shared across instances and how they differ from instance attributes.

Clarified how to manage internal counters (e.g., ID generators) and why class methods are suitable for such use.

Requested debugging guidance when I encountered incorrect behavior due to misusing self instead of cls in class methods.

Asked for help in improving code readability, such as how to properly separate responsibilities between helper classes and utility methods.

Explored examples of how static methods can encapsulate reusable logic without depending on object state.

Sought simplified analogies to better understand encapsulation and how to keep classes cohesive but not tightly coupled.

Reflection:

This week, AI helped me deepen my understanding of structured object-oriented design. Instead of treating classes as containers for random functions, I became more aware of how class responsibilities should be clearly defined. I also gained confidence in selecting the right type of method depending on the context. More importantly, I learned to validate my own reasoning by checking whether a method truly required access to instance data, class-level data, or could function independently. This helped shift my learning process from writing code that “works” to designing code that is logical, maintainable, and well-structured.
